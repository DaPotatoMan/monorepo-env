import fs from 'node:fs'
import process from 'node:process'
import { loadEnv } from 'vite'
import { monorepoRootSync } from 'monorepo-root'
import { camelCase } from 'scule'
import { prepareDir, resolvePath } from './utils'
import { type EnvMap, type NuxtRuntimeEnvMap, createViteTypes } from './types'

export interface EnvGeneratorConfig {
  /**
   * Current project path
   * @default ```ts
   * process.cwd()
   * ```
   */
  cwd?: string

  /** Monorepo project root path */
  root?: string

  /**
   * List of directories to scan in low to high priority
   * @default [root,cwd]
   */
  dirs?: string[]

  /**
   * Folder where .env file will be generated
   * @default node_modules/.env
   */
  outputDir?: string

  /**
   * Path of env types
   * @default {cwd}/env.d.ts
   */
  dts?: boolean | `${string}.d.ts`

  /**
   * Prefixed env variables to load
   * @default ```ts
   * ['NUXT', 'VITE']
   * ```
   */
  prefixes?: string[]
}

export function getRootDir() {
  const path = monorepoRootSync()

  if (!path)
    throw new Error('Unable to determine project root.')

  return path
}

/** Generates .env file content */
function getEnvContent(mode: string, data: EnvMap) {
  let content = `# Generated by monorepo-env\n# mode = ${mode}\n`

  for (const key in data)
    content += `\n${key}=${data[key]}`

  return content
}

export function generateENV(mode: string, {
  cwd = process.cwd(),
  root = getRootDir(),
  dirs = [root, cwd],
  outputDir: outputDirRaw = 'node_modules/.env',
  dts = true,
  prefixes = ['NUXT_', 'VITE_'],
}: Partial<EnvGeneratorConfig> = {}) {
  /** Where .env file will be generated */
  const outputDir = resolvePath(cwd, outputDirRaw)

  /** Generated .env path */
  const outputPath = resolvePath(outputDir, '.env')

  /** Parsed env map */
  const data = dirs.reduce(
    (map, path) => ({ ...map, ...loadEnv(mode, path, prefixes) }),
    {},
  )

  const envContent = getEnvContent(mode, data)
  const dtsContent = createViteTypes(mode, data)

  // Generate .env file
  prepareDir(outputDir)
  fs.writeFileSync(outputPath, envContent)

  // Generate dts file
  if (dts) {
    const dtsPath = resolvePath(typeof dts === 'string' ? dts : 'env.d.ts')
    fs.writeFileSync(dtsPath, dtsContent)
  }

  return { data, outputDir, outputPath, dtsContent }
}

export function getNuxtRuntimeEnvMap(baseENV: EnvMap) {
  const data: NuxtRuntimeEnvMap = {
    public: {},
    private: {},
  }

  for (const key in baseENV) {
    // Only handle NUXT_* keys
    if (!key.startsWith('NUXT_'))
      continue

    const isPublic = key.startsWith('NUXT_PUBLIC')
    const name = camelCase(
      key.replace(/NUXT_PUBLIC_|NUXT_/gm, ''),
      { normalize: true },
    )

    // Add env to record
    data[isPublic ? 'public' : 'private'][name] = baseENV[key]
  }

  return data
}
